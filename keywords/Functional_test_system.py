import time
import os
from appium import webdriver
from appium.webdriver.common.appiumby import AppiumBy
from appium.options.common import AppiumOptions
import cv2
from paddleocr import PaddleOCR
import numpy as np
import subprocess

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
APPIUM_SERVER_URL = "http://127.0.0.1:4723"
SCREENSHOT_PATH = os.path.normpath(os.path.join(BASE_DIR, "..", "screenshots_system"))
os.makedirs(SCREENSHOT_PATH, exist_ok=True)


def detect_devices():
    print("\nüì° D√©tection des devices connect√©s...")
    result = subprocess.run(["adb", "devices", "-l"], capture_output=True, text=True)
    devices = []

    for line in result.stdout.splitlines():
        if "device" in line and not line.startswith("List"):
            parts = line.split()
            udid = parts[0]
            description = " ".join(parts[1:])
            devices.append((udid, description))

    aaos_device = None
    phone_device = None

    for udid, desc in devices:
        if "emulator" in udid and ("car" in desc or "car" in udid):
            aaos_device = udid
        elif "emulator" in udid:
            phone_device = udid

    if not aaos_device or not phone_device:
        print("‚ùå Impossible de d√©tecter les deux devices. Devices trouv√©s:", devices)
        raise Exception("Erreur de d√©tection devices")

    print(f"‚úÖ D√©tection termin√©e : Phone={phone_device}, AAOS={aaos_device}")
    return phone_device, aaos_device

PHONE_UDID, AAOS_UDID = detect_devices()

os.makedirs(SCREENSHOT_PATH, exist_ok=True)

# Variables Globales
driver_phone = None
driver_aaos = None

def init_driver(udid, device_name):
    options = AppiumOptions()
    options.set_capability("platformName", "Android")
    options.set_capability("deviceName", device_name)
    options.set_capability("udid", udid)
    options.set_capability("automationName", "UiAutomator2")
    return webdriver.Remote(APPIUM_SERVER_URL, options=options)


def click_xpath(driver, xpath, description="", timeout=5):
    print(f"üî± Action : {description}")
    end_time = time.time() + timeout
    while time.time() < end_time:
        try:
            element = driver.find_element(AppiumBy.XPATH, xpath)
            element.click()
            print(f"‚úÖ Cliqu√© sur {description}")
            return True
        except Exception:
            time.sleep(0.5)
    print(f"‚ùå Impossible de cliquer sur {description}")
    return False

def wait(seconds):
    print(f"‚è≥ Attente {seconds} secondes...")
    time.sleep(seconds)

def launch_settings_via_adb(udid):
    print(f"üöÄ Lancement manuel de Settings via adb pour {udid}...")
    os.system(f"adb -s {udid} shell am start -n com.android.settings/.Settings")
    wait(2)

def get_bluetooth_status(udid):
    print(f"üîç V√©rification Bluetooth via adb pour {udid}...")
    output = os.popen(f"adb -s {udid} shell settings get global bluetooth_on").read().strip()
    if output == "1":
        print("‚úÖ Bluetooth est ACTIV√â")
        return True
    elif output == "0":
        print("‚úÖ Bluetooth est D√âSACTIV√â")
        return False
    else:
        print(f"‚ö†Ô∏è Impossible de lire l'√©tat Bluetooth : {output}")
        return None

def capture_screenshot(driver, device_name, state_label):
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    filename = f"{device_name}_bluetooth_{state_label}_{timestamp}.png"
    filepath = os.path.join(SCREENSHOT_PATH, filename)
    driver.save_screenshot(filepath)
    print(f"üì∑ Capture enregistr√©e : {filepath}")

def toggle_bluetooth_ui(driver, expected_state, device_name):
    print(f"üîÑ Basculement Bluetooth via UI, attendu : {expected_state}")
    try:
        switch_xpath = '//android.widget.Switch'
        switch = driver.find_element(AppiumBy.XPATH, switch_xpath)
        current_state = switch.get_attribute('checked') == 'true'

        print(f"üóÖÔ∏è Etat actuel Bluetooth (UI) : {current_state}")

        if current_state != expected_state:
            print(f"üîÑ Action n√©cessaire ‚ûî Clique sur Switch...")
            switch.click()
            wait(2)
            capture_screenshot(driver, f"{device_name}_toggle_done")
        else:
            print(f"‚úÖ Bluetooth est d√©j√† dans l'√©tat souhait√© (pas besoin de cliquer)")
            capture_screenshot(driver, f"{device_name}_no_toggle_needed")

    except Exception as e:
        print(f"‚ùå Erreur Switch Bluetooth UI : {e}")


# ------------------------
# Navigation Settings
# ------------------------

def open_phone_settings_and_navigate():
    global driver_phone

    print("üì± Initialisation Phone et navigation Bluetooth...")
    try:
        driver_phone = init_driver(PHONE_UDID, "emulator-5556")
        driver_phone.press_keycode(3)
        wait(2)

        xpath_settings_icon = '(//android.widget.TextView[@content-desc="Settings"])[2]'
        success = click_xpath(driver_phone, xpath_settings_icon, "Ouvrir Settings Phone (via NexusLauncher)")

        if not success:
            print("‚ö†Ô∏è Ic√¥ne Settings introuvable, tentative via adb...")
            launch_settings_via_adb(PHONE_UDID)
            wait(2)

        connected_devices_xpath = '//androidx.recyclerview.widget.RecyclerView[@resource-id="com.android.settings:id/recycler_view"]/android.widget.LinearLayout[3]'
        click_xpath(driver_phone, connected_devices_xpath, "Ouvrir Connected Devices")
        wait(1)

        pair_new_devices_xpath = '//androidx.recyclerview.widget.RecyclerView[@resource-id="com.android.settings:id/recycler_view"]/android.widget.LinearLayout[1]'
        click_xpath(driver_phone, pair_new_devices_xpath, "Ouvrir Pair New Devices")
        wait(1)

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur ouverture + navigation Phone : {e}")

def open_aaos_settings():
    global driver_aaos

    print("üöó Initialisation AAOS...")
    driver_aaos = init_driver(AAOS_UDID, "emulator-5554")
    wait(2)

    # Ouvrir Settings directement via adb
    print("üöÄ Lancement Settings AAOS via adb...")
    os.system(f"adb -s {AAOS_UDID} shell am start -n com.android.car.settings/com.android.car.settings.Settings_Launcher_Homepage")
    wait(2)
    print("‚úÖ Settings AAOS ouvert via adb.")


# ------------------------
# Pairing Fonctions
# ------------------------

def pair_new_device_on_aaos(driver):
    print("üîó D√©marrage du Pairing AAOS...")
    try:
        pair_new_device_xpath = '//androidx.recyclerview.widget.RecyclerView[@resource-id="com.android.car.settings:id/car_ui_internal_recycler_view"]/android.widget.RelativeLayout[2]'
        click_xpath(driver, pair_new_device_xpath, "Ouvrir Pair New Device")
        wait(1)

        phone_device_xpath = '//android.view.ViewGroup[@resource-id="com.android.car.settings:id/multi_action_preference_first_action_container"]'
        click_xpath(driver, phone_device_xpath, "S√©lectionner sdk_gphone64_x86_64")
        wait(1)

        pair_button_xpath = '//android.widget.Button[@resource-id="android:id/button1"]'
        click_xpath(driver, pair_button_xpath, "Cliquer sur Pair AAOS")
        wait(1)

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur Pairing AAOS : {e}")

def confirm_pairing_on_phone(driver):
    print("üì± Confirmation Pairing Phone...")
    try:
        allow_contacts_switch_xpath = '//android.widget.Switch[@content-desc="Also allow access to contacts and call history"]'
        click_xpath(driver, allow_contacts_switch_xpath, "Activer acc√®s aux contacts")
        wait(1)

        pair_button_xpath = '//android.widget.Button[@resource-id="android:id/button1"]'
        click_xpath(driver, pair_button_xpath, "Confirmer Pair Phone")
        wait(3)

        allow_button_xpath = '//android.widget.Button[@resource-id="android:id/button1"]'
        click_xpath(driver, allow_button_xpath, "Autoriser acc√®s Phone")
        wait(1)

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur confirmation Pairing Phone : {e}")

def finalize_pairing_on_aaos(driver):
    print("üöó Finalisation Pairing AAOS...")
    try:
        continue_button_xpath = '//android.widget.Button[@resource-id="android:id/button1"]'
        click_xpath(driver, continue_button_xpath, "Cliquer sur Continue AAOS")
        wait(1)

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur finalisation Pairing AAOS : {e}")
        
def test_bluetooth_pairing():
    """Test complet du Bluetooth Pairing entre Phone et AAOS."""
    print("\nüöÄ TEST : Bluetooth Pairing Phone <--> AAOS")

    try:
        # 1. Initialiser le t√©l√©phone
        open_phone_settings_and_navigate()

        # 2. Pairing c√¥t√© AAOS
        pair_new_device_on_aaos(driver_aaos)

        # 3. Confirmer pairing c√¥t√© Phone
        confirm_pairing_on_phone(driver_phone)

        # 4. Finaliser pairing c√¥t√© AAOS
        finalize_pairing_on_aaos(driver_aaos)

        # 5. V√©rification OCR que le Phone est bien connect√© sur AAOS
        verify_connection_with_ocr(driver_aaos, "aaos")

        print("‚úÖ Test Bluetooth Pairing + V√©rification OCR r√©ussi entre Phone et AAOS.")

    except Exception as e:
        print(f"‚ùå Erreur lors du test de Bluetooth Pairing : {e}")


# ------------------------
# Test Bluetooth
# ------------------------

def full_bluetooth_test(driver, udid, device_name):
    print(f"üéØ Test Bluetooth sur {device_name}...")

    initial_state = get_bluetooth_status(udid)
    if initial_state is None:
        print(f"‚ùå Impossible de tester Bluetooth sur {device_name}")
        return

    toggle_bluetooth_ui(driver, not initial_state, device_name)
    wait(2)
    state_after_toggle = get_bluetooth_status(udid)

    if state_after_toggle == (not initial_state):
        print(f"‚úÖ Bascule r√©ussie ({initial_state} ‚ûî {state_after_toggle}) sur {device_name}")
    else:
        print(f"‚ùå Erreur bascule sur {device_name}")

    toggle_bluetooth_ui(driver, initial_state, device_name)
    wait(2)
    state_after_retoggle = get_bluetooth_status(udid)

    if state_after_retoggle == initial_state:
        print(f"‚úÖ Retour √† l'√©tat initial ({state_after_toggle} ‚ûî {state_after_retoggle}) sur {device_name}")
    else:
        print(f"‚ùå Erreur retour √©tat initial sur {device_name}")


def verify_connection_with_ocr(driver, device_name):
    print("üîç V√©rification OCR du statut de connexion...")

    try:
        # 1. Capture de l'√©cran complet
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        screenshot_path = os.path.join(SCREENSHOT_PATH, f"{device_name}_final_check_{timestamp}.png")
        driver.save_screenshot(screenshot_path)
        print(f"üì∏ Capture pour OCR sauvegard√©e : {screenshot_path}")

        # 2. Chargement et crop de l'image
        image = cv2.imread(screenshot_path)
        cropped_image = image[469:502, 747:947]  # [y1:y2, x1:x2]
        cropped_path = os.path.join(SCREENSHOT_PATH, f"{device_name}_cropped_check_{timestamp}.png")
        cv2.imwrite(cropped_path, cropped_image)
        print(f"‚úÇÔ∏è Image cropp√©e sauvegard√©e : {cropped_path}")

        # 3. OCR sur l'image cropp√©e
        ocr = PaddleOCR(use_angle_cls=True, lang='en')
        result = ocr.ocr(cropped_path, cls=True)

        detected_text = ""
        for line in result[0]:
            detected_text += line[1][0] + " "

        print(f"üß† Texte d√©tect√© par OCR : {detected_text.strip()}")

        # 4. V√©rification du mot cl√© "Connected"
        if "Connected" in detected_text:
            print("‚úÖ V√©rification OCR : Appareil connect√© avec succ√®s !")
        else:
            print("‚ùå V√©rification OCR : 'Connected' non d√©tect√©.")

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur pendant la v√©rification OCR : {e}")


# ------------------------
# test Wi-Fi
# ------------------------

def test_wifi_connection(driver):
    """ Test complet du Wi-Fi : Activation/D√©sactivation + V√©rification UI/ADB + OCR AndroidWifi """
    print("\nüöÄ TEST : Wi-Fi Activation/Deactivation + ADB V√©rification + OCR AndroidWifi")

    try:
        # 1. Cliquer sur Network & Internet directement
        print("üì± Clic sur Network & Internet...")
        driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[contains(@text, "Network")]').click()
        time.sleep(2)

        # 2. Lire √©tat actuel du Wi-Fi via UI
        wifi_switch_xpath = '//android.widget.Switch[@resource-id="android:id/switch_widget"]'
        wifi_switch = driver.find_element(AppiumBy.XPATH, wifi_switch_xpath)
        ui_wifi_state = wifi_switch.get_attribute("checked") == "true"
        print(f"üì° Wi-Fi UI State (avant action) : {'ON' if ui_wifi_state else 'OFF'}")

        # 3. Action selon l'√©tat d√©tect√©
        if not ui_wifi_state:
            print("‚ö° Wi-Fi d√©sactiv√© ‚ûî Activation en cours...")
            wifi_switch.click()
            time.sleep(3)

            # V√©rification ADB apr√®s activation
            adb_wifi_state = os.popen(f"adb -s {AAOS_UDID} shell settings get global wifi_on").read().strip()
            adb_wifi_state = int(adb_wifi_state) if adb_wifi_state.isdigit() else -1
            print(f"üîç ADB Wi-Fi State apr√®s activation : {adb_wifi_state}")

            if adb_wifi_state == 1:
                print("‚úÖ ADB confirme que Wi-Fi est activ√©.")
            else:
                print("‚ùå ADB ne confirme pas l'activation du Wi-Fi.")
        else:
            print("‚ö° Wi-Fi activ√© ‚ûî D√©sactivation + R√©activation...")
            wifi_switch.click()
            time.sleep(3)

            # V√©rification ADB apr√®s d√©sactivation
            adb_wifi_state = os.popen(f"adb -s {AAOS_UDID} shell settings get global wifi_on").read().strip()
            adb_wifi_state = int(adb_wifi_state) if adb_wifi_state.isdigit() else -1
            print(f"üîç ADB Wi-Fi State apr√®s d√©sactivation : {adb_wifi_state}")

            if adb_wifi_state == 0:
                print("‚úÖ ADB confirme que Wi-Fi est d√©sactiv√©.")
            else:
                print("‚ùå ADB ne confirme pas la d√©sactivation du Wi-Fi.")

            # R√©activer
            wifi_switch = driver.find_element(AppiumBy.XPATH, wifi_switch_xpath)  # Recharger l'√©l√©ment
            wifi_switch.click()
            time.sleep(3)

            # V√©rification ADB apr√®s r√©activation
            adb_wifi_state = os.popen(f"adb -s {AAOS_UDID} shell settings get global wifi_on").read().strip()
            adb_wifi_state = int(adb_wifi_state) if adb_wifi_state.isdigit() else -1
            print(f"üîç ADB Wi-Fi State apr√®s r√©activation : {adb_wifi_state}")

            if adb_wifi_state == 1:
                print("‚úÖ ADB confirme que Wi-Fi est r√©activ√©.")
            else:
                print("‚ùå ADB ne confirme pas la r√©activation du Wi-Fi.")

        # 4. Capture et OCR pour v√©rifier AndroidWifi
        print("üì∏ Capture et OCR pour d√©tecter AndroidWifi...")
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        screenshot_path = os.path.join(SCREENSHOT_PATH, f"wifi_check_{timestamp}.png")
        driver.save_screenshot(screenshot_path)

        # Crop uniquement AndroidWifi
        image = cv2.imread(screenshot_path)
        wifi_name_crop = image[611:654, 763:929]  # [y1:y2, x1:x2]
        wifi_name_path = os.path.join(SCREENSHOT_PATH, f"cropped_wifi_name_{timestamp}.png")
        cv2.imwrite(wifi_name_path, wifi_name_crop)

        # OCR
        ocr = PaddleOCR(use_angle_cls=True, lang='en')
        result = ocr.ocr(wifi_name_path, cls=True)

        if result and len(result) > 0 and len(result[0]) > 0:
            detected_wifi_name = ""
            for line in result[0]:
                detected_wifi_name += line[1][0] + " "

            detected_wifi_name = detected_wifi_name.strip()
            print(f"üß† Texte d√©tect√© Wi-Fi Name : {detected_wifi_name}")

            if "AndroidWifi" in detected_wifi_name:
                print("‚úÖ Wi-Fi AndroidWifi d√©tect√© correctement via OCR apr√®s Activation.")
            else:
                print("‚ùå AndroidWifi non d√©tect√© via OCR apr√®s Activation.")
        else:
            print("‚ùå Aucune d√©tection OCR trouv√©e pour AndroidWifi apr√®s Activation.")

    except Exception as e:
        print(f"‚ùå Erreur pendant le test Wi-Fi : {e}")


def open_display_settings(driver):
    print("üì± Ouverture Param√®tres > Display...")
    time.sleep(2)
    # C'est le 5√®me item dans RecyclerView (pas le 2√®me)
    driver.find_element(AppiumBy.XPATH, '//androidx.recyclerview.widget.RecyclerView[@resource-id="com.android.car.settings:id/car_ui_recycler_view"]/android.widget.RelativeLayout[5]').click()
    time.sleep(2)


def get_brightness_level(driver):
    slider = driver.find_element(AppiumBy.CLASS_NAME, "android.widget.SeekBar")
    x = slider.location["x"]
    width = slider.size["width"]
    thumb_center_x = x + width / 2
    return thumb_center_x, width

def move_brightness_slider(driver, position="right"):
    slider = driver.find_element(AppiumBy.CLASS_NAME, "android.widget.SeekBar")
    start_x = slider.location["x"]
    start_y = slider.location["y"]
    width = slider.size["width"]

    target_x = start_x + int(width * (0.8 if position == "right" else 0.2))
    driver.swipe(start_x + int(width/2), start_y, target_x, start_y, 800)
    print(f"‚úÖ Curseur d√©plac√© vers {'droite' if position == 'right' else 'gauche'}")
    time.sleep(2)

def capture_screenshot(driver, name):
    full_path = os.path.join(SCREENSHOT_PATH, f"{name}.png")
    driver.save_screenshot(full_path)
    print(f"üì∏ Capture enregistr√©e : {full_path}")
    return full_path

def compare_screenshots(img1_path, img2_path):
    img1 = cv2.imread(img1_path)
    img2 = cv2.imread(img2_path)

    if img1 is None or img2 is None:
        print("‚ùå Images non charg√©es.")
        return False

    img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
    diff = cv2.absdiff(img1_gray, img2_gray)
    _, thresh = cv2.threshold(diff, 30, 255, cv2.THRESH_BINARY)

    changed_pixels = np.count_nonzero(thresh)
    total_pixels = thresh.size
    percent_change = (changed_pixels / total_pixels) * 100

    print(f"üìä Pourcentage changement : {percent_change:.4f}%")
    return percent_change > 0.3

def toggle_adaptive_brightness(driver):
    toggle = driver.find_element(AppiumBy.CLASS_NAME, "android.widget.Switch")
    toggle.click()
    print("üîÑ Switch 'Adaptive Brightness' activ√©/d√©sactiv√©")
    time.sleep(3)

def test_brightness_slider_functionality(driver):
    print("\nüöÄ TEST : Brightness Slider Fonctionnel ?")
    open_display_settings(driver)

    move_brightness_slider(driver, "right")
    capture_screenshot(driver, "brightness_high")

    move_brightness_slider(driver, "left")
    capture_screenshot(driver, "brightness_low")

    img_high = os.path.join(SCREENSHOT_PATH, "brightness_high.png")
    img_low = os.path.join(SCREENSHOT_PATH, "brightness_low.png")
    result = compare_screenshots(img_high, img_low)

    if result:
        print("‚úÖ Brightness Slider fonctionne correctement (diff√©rence d√©tect√©e).")
    else:
        print("‚ùå Brightness Slider NE fonctionne PAS (aucune diff√©rence d√©tect√©e).")

def test_adaptive_brightness_functionality(driver):
    print("\nüöÄ TEST : Adaptive Brightness Fonctionnel ?")
    open_display_settings(driver)

    initial_level, width = get_brightness_level(driver)
    print(f"üìè Niveau initial luminosit√© : {initial_level:.2f}")

    toggle_adaptive_brightness(driver)

    after_toggle_level, _ = get_brightness_level(driver)
    print(f"üìè Niveau apr√®s changement : {after_toggle_level:.2f}")

    if abs(initial_level - after_toggle_level) > width * 0.05:
        print("‚úÖ Adaptive Brightness fonctionne (niveau chang√© automatiquement).")
    else:
        print("‚ùå Adaptive Brightness NE fonctionne PAS (niveau inchang√©).")

# --- Fonctions Date & Time Correctes ---

def navigate_to_date_time_settings(driver):
    """Depuis Display, naviguer vers Date & Time"""
    print("üìÖ Navigation vers Date & Time...")
    wait(1)

    # On est dans Display ‚ûî maintenant clique sur "Date & Time"
    date_time_xpath = '//androidx.recyclerview.widget.RecyclerView[@resource-id="com.android.car.settings:id/car_ui_internal_recycler_view"]/android.widget.RelativeLayout[2]'
    success = click_xpath(driver, date_time_xpath, "Ouvrir Date & Time depuis Display")
    if not success:
        print("‚ùå Impossible d'ouvrir Date & Time depuis Display.")
        return False

    wait(2)
    return True

def disable_automatic_time(driver):
    """V√©rifie et d√©sactive 'Set time automatically' si activ√©"""
    print("üîç V√©rification du mode automatique...")
    try:
        toggle_xpath = '//android.widget.Switch[@resource-id="android:id/switch_widget"]'
        toggle_element = driver.find_element(AppiumBy.XPATH, toggle_xpath)
        is_enabled = toggle_element.get_attribute("checked")

        if is_enabled == "true":
            print("‚ö†Ô∏è 'Set time automatically' activ√© ‚ûî D√©sactivation...")
            toggle_element.click()
            time.sleep(2)
            print("‚úÖ 'Set time automatically' d√©sactiv√©.")
        else:
            print("‚úÖ 'Set time automatically' d√©j√† d√©sactiv√©.")
    except Exception as e:
        print(f"‚ùå Erreur d√©sactivation automatique : {e}")

def get_current_date():
    """R√©cup√®re la date actuelle via ADB"""
    result = os.popen(f"adb -s {AAOS_UDID} shell date '+%Y-%m-%d'").read().strip()
    print(f"üìÜ Date actuelle : {result}")
    return result

def get_current_time():
    """R√©cup√®re l'heure actuelle via ADB"""
    result = os.popen(f"adb -s {AAOS_UDID} shell date '+%H:%M'").read().strip()
    print(f"‚è∞ Heure actuelle : {result}")
    return result

def change_date(driver):
    """Change la date"""
    print("üìÖ Changement de la date...")

    try:
        # Essayer de cliquer sur 'Set date'
        set_date_button = driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[@text="Set date"]')
        set_date_button.click()
        time.sleep(2)

        # Tap dans le s√©lecteur de date
        os.system(f"adb -s {AAOS_UDID} shell input tap 846 532")  # Mois
        time.sleep(1)
        os.system(f"adb -s {AAOS_UDID} shell input tap 976 532")  # Jour
        time.sleep(1)
        os.system(f"adb -s {AAOS_UDID} shell input tap 1095 532")  # Ann√©e
        time.sleep(1)

        # Confirmer (ENTER)
        os.system(f"adb -s {AAOS_UDID} shell input keyevent 66")
        time.sleep(2)

    except Exception as e:
        print(f"‚ùå Impossible de changer la date : {e}")

def change_time(driver):
    """Change l'heure"""
    print("‚è∞ Changement de l'heure...")

    try:
        set_time_button = driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[@text="Set time"]')
        set_time_button.click()
        time.sleep(2)

        # Tap dans le s√©lecteur d'heure
        os.system(f"adb -s {AAOS_UDID} shell input tap 852 522")  # Heure
        time.sleep(1)
        os.system(f"adb -s {AAOS_UDID} shell input tap 981 532")  # Minutes
        time.sleep(1)
        os.system(f"adb -s {AAOS_UDID} shell input tap 1107 339")  # Minutes
        time.sleep(1)
        # Confirmer (ENTER)
        os.system(f"adb -s {AAOS_UDID} shell input keyevent 66")
        time.sleep(2)

    except Exception as e:
        print(f"‚ùå Impossible de changer l'heure : {e}")

def go_back(driver):
    """Retour arri√®re"""
    print("‚Ü©Ô∏è Retour arri√®re...")
    try:
        back_button_xpath = '//android.widget.ImageView[@resource-id="com.android.car.settings:id/car_ui_toolbar_nav_icon"]'
        driver.find_element(AppiumBy.XPATH, back_button_xpath).click()
        time.sleep(2)
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur retour arri√®re : {e}")

def verify_date_changed(old_date):
    """V√©rifie changement de date"""
    new_date = get_current_date()
    print(f"üîÑ Date : Avant = {old_date} | Apr√®s = {new_date}")
    if old_date != new_date:
        print("‚úÖ Date modifi√©e avec succ√®s.")
        return True
    else:
        print("‚ùå Date inchang√©e.")
        return False

def verify_time_changed(old_time):
    """V√©rifie changement d'heure"""
    new_time = get_current_time()
    print(f"üîÑ Heure : Avant = {old_time} | Apr√®s = {new_time}")
    if old_time != new_time:
        print("‚úÖ Heure modifi√©e avec succ√®s.")
        return True
    else:
        print("‚ùå Heure inchang√©e.")
        return False

# --- TESTS ---

def test_date_change(driver):
    """Test complet de changement de la date"""
    print("\nüöÄ TEST DATE CHANGE üöÄ")
    if not navigate_to_date_time_settings(driver):
        print("‚ùå Navigation √©chou√©e vers Date & Time.")
        return

    disable_automatic_time(driver)

    old_date = get_current_date()
    change_date(driver)
    go_back(driver)

    if verify_date_changed(old_date):
        print("‚úÖ Test de changement de date PASSED")
    else:
        print("‚ùå Test de changement de date FAILED")

def test_time_change(driver):
    """Test complet de changement de l'heure"""
    print("\nüöÄ TEST TIME CHANGE üöÄ")
    if not navigate_to_date_time_settings(driver):
        print("‚ùå Navigation √©chou√©e vers Date & Time.")
        return

    disable_automatic_time(driver)

    old_time = get_current_time()
    change_time(driver)
    go_back(driver)

    if verify_time_changed(old_time):
        print("‚úÖ Test de changement d'heure PASSED")
    else:
        print("‚ùå Test de changement d'heure FAILED")
def change_language_cycle(driver):
    """Test complet : passage English ‚ûî Fran√ßais ‚ûî retour English"""
    print("\nüöÄ D√©but du test de changement de langue üöÄ")

    # üìú 1. Navigation initiale
    try:
        print("üìú D√©filement vers 'System'...")
        wait(1)
        driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR,
            'new UiScrollable(new UiSelector().scrollable(true)).scrollIntoView(new UiSelector().textContains("System"))')
        driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[@text="System"]').click()
        time.sleep(2)

        print("üåç Acc√®s √† 'Languages & input'...")
        driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[contains(@text,"Languages")]').click()
        time.sleep(2)

        print("üåê Acc√®s √† 'Languages'...")
        driver.find_element(AppiumBy.XPATH,
            '//android.widget.TextView[@resource-id="android:id/title" and (@text="Languages" or @text="Langues")]').click()
        time.sleep(2)

    except Exception as e:
        print(f"‚ùå Erreur navigation initiale : {e}")
        return

    # üìñ 2. Langue actuelle AVANT
    previous_language = os.popen(f"adb -s {AAOS_UDID} shell getprop persist.sys.locale").read().strip()
    print(f"üìñ Langue actuelle AVANT changement : {previous_language}")

    # üîµ 3. Passage en Fran√ßais
    print("\nüîµ Passage en Fran√ßais...")

    try:
        # Scroll pour trouver "Fran√ßais"
        found = False
        for _ in range(10):
            try:
                driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[@text="Fran√ßais"]').click()
                found = True
                break
            except:
                print("üîÑ 'Fran√ßais' non trouv√©, scroll...")
                os.system(f"adb -s {AAOS_UDID} shell input swipe 612 649 612 400")
                time.sleep(2)

        if not found:
            print("‚ùå 'Fran√ßais' non trouv√© apr√®s plusieurs scrolls.")
            return

        time.sleep(2)

        # S√©lection de Fran√ßais (France)
        driver.find_element(AppiumBy.XPATH, '//android.widget.TextView[@text="Fran√ßais (France)"]').click()
        time.sleep(3)

        new_language = os.popen(f"adb -s {AAOS_UDID} shell getprop persist.sys.locale").read().strip()
        print(f"üìñ Langue APRES passage en Fran√ßais : {new_language}")

        if "fr" in new_language:
            print("‚úÖ Passage en Fran√ßais r√©ussi.")
        else:
            print(f"‚ùå Passage en Fran√ßais √©chou√©. Langue actuelle: {new_language}")
            return

    except Exception as e:
        print(f"‚ùå Erreur pendant passage en Fran√ßais : {e}")
        return

    # üî¥ 4. Retour en Anglais
    print("\nüîÑ Retour en Anglais...")

    try:
        # üåê Re-cliquer sur "Languages" ("Langues")
        print("üåê Retour dans 'Languages'...")
        driver.find_element(AppiumBy.XPATH,
            '//android.widget.TextView[@resource-id="android:id/title" and (@text="Languages" or @text="Langues")]').click()
        time.sleep(2)

        # üî• Cliquer directement sur "English (United States)"
        print("üåê S√©lection de 'English (United States)'...")
        driver.find_element(AppiumBy.XPATH,
            '//android.widget.TextView[@text="English (United States)"]').click()
        time.sleep(3)

        final_language = os.popen(f"adb -s {AAOS_UDID} shell getprop persist.sys.locale").read().strip()
        print(f"üìñ Langue APRES retour en Anglais : {final_language}")

        if "en" in final_language:
            print("‚úÖ Retour en Anglais r√©ussi.")
        else:
            print(f"‚ùå Retour en Anglais √©chou√©. Langue actuelle: {final_language}")

    except Exception as e:
        print(f"‚ùå Erreur pendant retour en Anglais : {e}")

def close_settings():
    """Ferme uniquement l'application Settings AAOS."""
    print("‚è≥ Attente 3 secondes avant fermeture de Settings...")
    time.sleep(5)  # üïí Attendre 3 secondes AVANT de fermer

    print("üö™ Fermeture de Settings AAOS...")
    try:
        os.system(f"adb -s {AAOS_UDID} shell am force-stop com.android.car.settings")
        print("‚úÖ Settings ferm√© avec succ√®s.")
    except Exception as e:
        print(f"‚ùå Erreur lors de la fermeture de Settings : {e}")
if __name__ == "__main__":
    print("üöÄ D√©but des tests AAOS...")

    # Initialisation AAOS
    open_aaos_settings()

    # Test Bluetooth
    full_bluetooth_test(driver_aaos, AAOS_UDID, "aaos")
    # Test pairing
    test_bluetooth_pairing()

    # Test OCR Wi-Fi
    test_wifi_connection(driver_aaos)

    # Test Brightness Slider
    test_brightness_slider_functionality(driver_aaos)

    # Test Adaptive Brightness
    test_adaptive_brightness_functionality(driver_aaos)

    # Test Date Change
    test_date_change(driver_aaos)

    # Test Time Change
    test_time_change(driver_aaos)

    # Test Changement de langue (Fran√ßais ‚ûî Anglais)
    change_language_cycle(driver_aaos)

    # Fermeture Settings
    close_settings()

    print("‚úÖ Tous les tests termin√©s !")
